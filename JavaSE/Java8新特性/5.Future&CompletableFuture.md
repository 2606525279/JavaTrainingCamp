# Future 与 CompletableFuture



## 引入

前面我们学习多线程的时候，里面有关于future的部分，但是我们并没有详细介绍，接下来我们就来研究研究它。

我们知道，多线程有很多优点：

* 多线程能够避免线程阻塞，提高软件的影响速度。
* 多线程能够很好地利用CPU资源，提高CPU的利用率。
* 使用与CPU密集型的计算，比如图形图像处理，大数据运算等。

但是，同时缺点也不少：

* 多线程开发对初学者较难，不容易掌握，容易出现死锁等。
* 对于多线程来说，线程与线程之间的通信比较困难。
* 多线程不适用于处理异步请求。

前两条缺点我们前面已经说了，对于异步的处理，我们不是很了解，那么我们先来看看什么是异步与同步吧：



## 同步与异步

相信很多做过前端开发的小伙伴对异步的概念并不陌生，而且异步有很多优势，但是异步的概念在后端却发展缓慢，但仍旧需要大家了解：

**同步： 调用者发出调用指令之后，必须等待执行者执行完成之后，才能进行后续操作。**

**异步：调用者发出指令，在没有等到返回结果之前还可以继续处理其他操作，执行者执行完成之后通知调用者执行完成。**

从上面的概念来看，异步要求完成操作之后返回结果，那么多线程很难做到完成操作之后返回结果，所以，多线程不太适合处理异步请求，那么今天我们来看看Future模式是怎么解决这个问题的吧！



## Future

### 介绍

Future是JDK 1.5推出的功能，首先其内部是基于多线程，再者Future提供了一些接口方便控制异步流程和返回结果。

Future模式是多线程设计常用的一种设计模式。Future模式可以理解成：我有一个任务，提交给了Future，Future替我完成这个任务。期间我自己可以去做任何想做的事情。一段时间之后，我就便可以从Future那儿取出结果。

### Future接口

Future的接口很简单，只有五个方法。

```java
public interface Future<V> {

    boolean cancel(boolean mayInterruptIfRunning);

    boolean isCancelled();

    boolean isDone();

    V get() throws InterruptedException, ExecutionException;

    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
```

**方法介绍：**

| Modifier and Type | Method | Description                                       |
| ----------------- | ---------------|--------------------------------------------- |
| `boolean`         | **cancel**(boolean mayInterruptIfRunning)| Attempts to cancel execution of this task. |
| `V`               | **get**() |Waits if necessary for the computation to complete, and then retrieves its result. |
| `V`               | **get**(long timeout, TimeUnit unit) |Waits if necessary for at most the given time for the computation to complete, and then retrieves its result, if available. |
| `boolean`         | **isCancelled**() | Returns `true` if this task was cancelled before it completed normally. |
| `boolean`         | **isDone**() |Returns `true` if this task completed.         |

### 使用

一般情况下，我们会结合Callable和Future一起使用，通过ExecutorService的submit方法执行Callable，并返回Future。

```java
ExecutorService executor = Executors.newCachedThreadPool();
Future<String> future = executor.submit(() -> {
    System.out.println("running task");
    Thread.sleep(1000);
    return "complete task";
});

String result = future.get();
System.out.println(result);
executor.shutdown();
```



### Future缺陷

Future 虽然可以实现异步的方式，但是仍旧有下面两个问题：

* Future虽然可以实现获取异步执行结果的需求，但是它没有提供通知的机制，我们无法得知Future什么时候完成。
* 要么使用阻塞，在future.get()的地方等待future返回的结果，这时又变成同步操作。要么使用isDone()轮询地判断Future是否完成，这样会耗费CPU的资源。

这两个缺陷使得Future在异步处理上面捉襟见肘，所以，Java 8 提出了CompletableFuture来增强，下面我们详细了解一下：

## CompletableFuture

