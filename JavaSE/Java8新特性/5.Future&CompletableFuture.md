# Future 与 CompletableFuture



## 引入

前面我们学习多线程的时候，里面有关于future的部分，但是我们并没有详细介绍，接下来我们就来研究研究它。

我们知道，多线程有很多优点：

* 多线程能够避免线程阻塞，提高软件的影响速度。
* 多线程能够很好地利用CPU资源，提高CPU的利用率。
* 使用与CPU密集型的计算，比如图形图像处理，大数据运算等。

但是，同时缺点也不少：

* 多线程开发对初学者较难，不容易掌握，容易出现死锁等。
* 对于多线程来说，线程与线程之间的通信比较困难。
* 多线程不适用于处理异步请求。

前两条缺点我们前面已经说了，对于异步的处理，我们不是很了解，那么我们先来看看什么是异步与同步吧：



## 同步与异步

相信很多做过前端开发的小伙伴对异步的概念并不陌生，而且异步有很多优势，但是异步的概念在后端却发展缓慢，但仍旧需要大家了解：

**同步： 调用者发出调用指令之后，必须等待执行者执行完成之后，才能进行后续操作。**

**异步：调用者发出指令，在没有等到返回结果之前还可以继续处理其他操作，执行者执行完成之后通知调用者执行完成。**

从上面的概念来看，异步要求完成操作之后返回结果，那么多线程很难做到完成操作之后返回结果，所以，多线程不太适合处理异步请求，那么今天我们来看看Future模式是怎么解决这个问题的吧！



## [Future](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html)

### 介绍

Future是JDK 1.5推出的功能，首先其内部是基于多线程，再者Future提供了一些接口方便控制异步流程和返回结果。

Future模式是多线程设计常用的一种设计模式。Future模式可以理解成：我有一个任务，提交给了Future，Future替我完成这个任务。期间我自己可以去做任何想做的事情。一段时间之后，我就便可以从Future那儿取出结果。

### Future接口

Future的接口很简单，只有五个方法。

```java
public interface Future<V> {

    boolean cancel(boolean mayInterruptIfRunning);

    boolean isCancelled();

    boolean isDone();

    V get() throws InterruptedException, ExecutionException;

    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
```

**方法介绍：**

| Modifier and Type | Method | Description                                       |
| ----------------- | ---------------|--------------------------------------------- |
| `boolean`         | **cancel**(boolean mayInterruptIfRunning)| Attempts to cancel execution of this task. |
| `V`               | **get**() |Waits if necessary for the computation to complete, and then retrieves its result. |
| `V`               | **get**(long timeout, TimeUnit unit) |Waits if necessary for at most the given time for the computation to complete, and then retrieves its result, if available. |
| `boolean`         | **isCancelled**() | Returns `true` if this task was cancelled before it completed normally. |
| `boolean`         | **isDone**() |Returns `true` if this task completed.         |

### 使用

一般情况下，我们会结合Callable和Future一起使用，通过ExecutorService的submit方法执行Callable，并返回Future。

```java
ExecutorService executor = Executors.newCachedThreadPool();
Future<String> future = executor.submit(() -> {
    System.out.println("running task");
    Thread.sleep(1000);
    return "complete task";
});

String result = future.get();
System.out.println(result);
executor.shutdown();
```



### Future缺陷

Future 虽然可以实现异步的方式，但是仍旧有下面的几个问题：

* **It cannot be manually completed :**

  Let’s say that you’ve written a function to fetch the latest price of an e-commerce product from a remote API. Since this API call is time-consuming, you’re running it in a separate thread and returning a Future from your function.

  Now, let’s say that If the remote API service is down, then you want to complete the Future manually by the last cached price of the product.

  Can you do this with Future? No!

* **You cannot perform further action on a Future’s result without blocking:**

  Future does not notify you of its completion. It provides a `get()` method which **blocks** until the result is available.

  You don’t have the ability to attach a callback function to the Future and have it get called automatically when the Future’s result is available.

* **Multiple Futures cannot be chained together :**
  Sometimes you need to execute a long-running computation and when the computation is done, you need to send its result to another long-running computation, and so on.

  You can not create such asynchronous workflow with Futures.

* **You can not combine multiple Futures together :**

  Let’s say that you have 10 different Futures that you want to run in parallel and then run some function after all of them completes. You can’t do this as well with Future

* **No Exception Handling :** Future API does not have any exception handling construct.

这几个缺陷使得Future在异步处理上面捉襟见肘，所以，Java 8 提出了CompletableFuture来增强，下面我们详细了解一下：



## [CompletableFuture](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html)

### 介绍

> CompletableFuture能够将回调放到与任务不同的线程中执行，也能将回调作为继续执行的同步函数，在与任务相同的线程中执行。它避免了传统回调最大的问题，那就是能够将控制流分离到不同的事件处理器中。
>
> CompletableFuture弥补了Future模式的缺点。在异步的任务完成后，需要用其结果继续操作时，无需等待。可以直接通过thenAccept、thenApply、thenCompose等方式将前面异步处理的结果交给另外一个异步事件处理线程来处理。



### 静态API：

1. **runAsync 与 supplyAsync**

* runAsync(Runnable runnable)： 使用ForkJoinPool.commonPool()作为它的线程池执行异步代码。

* runAsync(Runnable runnable, Executor executor)： 使用指定的thread pool执行异步代码。
* supplyAsync(Supplier<U> supplier)： 使用ForkJoinPool.commonPool()作为它的线程池执行异步代码，异步操作有返回值
* supplyAsync(Supplier<U> supplier, Executor executor)： 使用指定的thread pool执行异步代码，异步操作有返回值

**需要注意的是：runAsync 返回的future是没有返回值的，而supplyAsync返回的future是由返回值的**！

```java
CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
    System.out.println("Hello");
});
future.get();

CompletableFuture<String> futureSupply = CompletableFuture.supplyAsync(() -> "Hello");
System.out.println(futureSupply.get());
```



2. **thenApply()**


## 参考链接

* [Guide to java.util.concurrent.Future](https://www.baeldung.com/java-future)
* [Guide To CompletableFuture](https://www.baeldung.com/java-completablefuture)
* [Java CompletableFuture Tutorial with Examples](https://www.callicoder.com/java-8-completablefuture-tutorial/)
* [CompletableFuture](https://www.jianshu.com/p/dff9063e1ab6)



## 家庭作业

