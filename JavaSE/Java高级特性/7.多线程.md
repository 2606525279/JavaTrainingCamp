# [多线程](https://docs.oracle.com/javase/tutorial/essential/concurrency/)

多线程是Java的重要概念，但同时也是一个难点，不容易掌握。说它是一个难点，主要是有以下几个方面：

* 概念的理解比较困难。多线程是操作系统底层的概念，Java对其进行了封装，但是学习难度依然没有降低。
* 多线程的使用有较高的门槛。线程是个好东西，但是用的不好就容易产生死锁等问题。
* 多线程使用的场景不多，经常学完就忘记了。

不过，大家也不用太过于恐慌，相信大家学完本节教程，上面的那些难点都不叫事！！



## 引入

在软件开发中，我们经常会遇到这样的情况：

* 磁盘读写。大家都知道，CPU先生的反应是很快的(因为人家聪明嘛，好比诸葛亮)，但是它(CPU)周围的某些同事(磁盘，数据库，网络请求)等都是反应很慢的家伙(臭皮匠)，完全配不上那么牛逼的CPU嘛，如果CPU发出一个指令去从磁盘上面读取文件，那么CPU接下来就只能等待漫长的磁盘读取过程了，啥事情也干不了了...
* 多核CPU效率较低。很久以前，计算机都是单核的，即只有一个CPU。但是现在的计算机都是多核的(四核，八核等), 大家可以设想：一个CPU都要等待，那么4个8个CPU该怎么办？如何提高他们的效率呢？大家都是花了大价钱买的CPU，能让其白白浪费么？
* 还有其他......这里就不列举了

那么如何解决这些问题呢？哈哈哈，当然是我们今天要学的多线程啦！

### 什么是线程？

> Threads are sometimes called ***lightweight processes***. Both processes and threads provide an execution environment, but creating a new thread requires fewer resources than creating a new process.

从上面的定义可以看出：线程就是一个轻量级的进程，一个单独的线程能够提供一个独立的运行环境。

我们知道，JAVA应用程序其实就是一个独立的进程，线程是一个轻量级的进程，那么什么是进程呢？

>A process has a self-contained execution environment. A process generally has a complete, private set of basic run-time resources; in particular, each process has its own memory space.

可以看出，进程是完全独立的，私有的运行过程，拥有独立的内存空间。

那么进程和线程有啥具体的区别呢？

### 线程与进程

**进程与线程，本质意义上说， 是操作系统的调度单位，可以看成是一种操作系统 “资源” 。**

**不同点：**

* [操作系统](http://lib.csdn.net/base/operatingsystem)资源管理方式不同：进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。
* **对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。**
* **一个程序至少有一个进程,一个进程至少有一个线程.**
* 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
* 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。**但是线程不能够独立执行，**必须依存在应用程序中，由应用程序提供多个线程执行控制。
* 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。**这就是进程和线程的重要区别。**

**优缺点：**

线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。

如果您想深入理解，请参考[这里](https://www.ibm.com/developerworks/cn/java/j-lo-processthread/index.html);

### 什么是多线程？

> A multithreaded program contains two or more parts that can run **concurrently**. Each part of such a program is called a thread and each thread defines a separate path of the execution. Thus, multithreading is a specialized form of multitasking.

上面的定义看起来有点难以理解，其实简单来看，多线程就是多个寄生在进程上的线程互相协作来完成工作的一种编程方式。

### 多线程的优势

1.  It **doesn't block the user(CPU)** because threads are independent and you can perform multiple operations at the same time.
2. You **can perform many operations together, so it saves time**.
3. Threads are **independent**, so it doesn't affect other threads if an exception occurs in a single thread.

从上面的几点优势可以看出，多线程能够提高CPU先生的效率，进而提高整个程序的性能，加深用户体验。

### 线程的生命周期

**线程是一个动态执行的过程，它也有一个从产生到死亡的过程。**如创建，执行，等待，死亡等过程。



![](http://ww1.sinaimg.cn/large/af4e9f79ly1fyonjmbzsaj21100hn400.jpg)

- **New** − A new thread begins its life cycle in the new state. It remains in this state until the program starts the thread. It is also referred to as a **born thread**.
- **Runnable** − After a newly born thread is started, the thread becomes runnable. A thread in this state is considered to be executing its task.
- **Waiting** − Sometimes, a thread transitions to the waiting state while the thread waits for another thread to perform a task. A thread transitions back to the runnable state only when another thread signals the waiting thread to continue executing.
- **Timed Waiting** − A runnable thread can enter the timed waiting state for a specified interval of time. A thread in this state transitions back to the runnable state when that time interval expires or when the event it is waiting for occurs.
- **Terminated (Dead)** − A runnable thread enters the terminated state when it completes its task or otherwise terminates.



## 创建线程

上面讲了很多理论知识，接下来我们就通过实战练一把。实现一个线程的常用方法有三种，下面我们主要介绍两种：

### 1. [Runnable](https://docs.oracle.com/javase/7/docs/api/java/lang/Runnable.html)

实现这个接口是创建自定义线程最简单的方式，基本上有下面三步就可以了：

**第一步：实现Runnable接口，重写run方法。**

```java
public class ThreadName implements Runnable {
    @Override 
    public void run() {
        //overide
    }
}
```

**第二步：调用Thread的构造函数创建线程对象，将实现Runnable的自定义线程类当做参数传入构造函数。**

**Thread(Runnable threadObj, String threadName)：第一个参数threadObj表示实现了Runnable的类，第二个参数是线程名称。**

```java
Runnable myThread = new ThreadName();
Thread thread = new Thread(myThread, "my_thread_name");
```

**第三步：调用线程对象的start()方法去执行一个线程，这个方法将会调用run()方法里面的代码。**

```java
thread.start();	
```

**举个例子：**

```java
public class MyThread implements Runnable {
    private String name;
    public MyThread(String name) {
        this.name = name;
    }
    
    @Override
    public void run() {
        System.out.println(this.name + " is running!");
    }
}

public class ThreadTest {
    public static void main(String[] args) {
        MyThread myThread = new MyThread("my_thread");
        Thread thread = new Thread(myThread);
        thread.start();
    }
}
```

**运行结果：**

```java
my_thread is running!
```



### 2. [Thread](https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html)

除了上面的创建线程方法之外，还可以直接继承Thread这个类，Thread类自己也实现了Runnable这个接口。用这个方式创建线程，只需要两步即可：

**第一步：继承Thread类并重写run方法：**

```java
public class ThreadName extends Thread {
    @Override 
    public void run() {
        //overide
    }
}
```

**第二步：创建线程对象，并调用start()方法。**

```java
Thread myThread = new ThreadName();
myThread.start();
```

**举个例子：**

```java
public class MineThread extends Thread {
    private String name;
    public MineThread(String name) {
        super(name);
        this.name = name;
    }
    
    @Override
    public void run() {
        System.out.println(this.name + " is running!");
    }
}

public class ThreadTest {
    public static void main(String[] args) {
        Thread thread = new MineThread("my_thread");
        thread.start();
    }
}
```

**运行结果：**

```java
my_thread is running!
```



#### Thread类的构造方法：

这个类的构造方法有好多个，常用的如下：

|               Constructor                | Description                                    |
| :--------------------------------------: | :--------------------------------------------- |
|               **Thread()**               | This allocates a new Thread object.            |
|       **Thread(Runnable target)**        | This allocates a new Thread object.            |
|         **Thread(String name)**          | This constructs allocates a new Thread object. |
| **Thread(Runnable target, String name)** | This allocates a new Thread object.            |

#### Thread类的成员方法：

这个类有很多构造方法，请同学们查阅相关资料自学以下方法：

* **[Thread currentThread()](https://www.tutorialspoint.com/java/lang/thread_currentthread.htm)**
* **[void interrupt()](https://www.tutorialspoint.com/java/lang/thread_interrupt.htm)**
* **[String getName()](https://www.tutorialspoint.com/java/lang/thread_getname.htm)**
* [**boolean isAlive()**](https://www.tutorialspoint.com/java/lang/thread_isalive.htm)
* [**void join()**](https://www.tutorialspoint.com/java/lang/thread_join.htm)
* **[void join(long millis)](https://www.tutorialspoint.com/java/lang/thread_join_millis.htm)**
* **[void sleep(long millis)](https://www.tutorialspoint.com/java/lang/thread_sleep_millis.htm)**



### 3. Callable 和 Future

第三种创建线程的方式本节课不做讲解，如果大家想进一步学习的话，请自学完成。



## 线程的其他重要概念

### 同步与异步

### 通信

### 死锁

### 线程控制



## 家庭作业

1. 比较Runable和Thread类实现线程的异同。

2. 假设从武汉到北京的火车票有500张，有三种方式可以售票：

   * 火车站售票窗口，每隔1秒钟可以售出一张票。
   * 12306官网，每隔10秒钟可以售出一张票。
   * 携程APP，每隔5秒钟可以售出一张票。

   当所有的票卖完时，统计各个渠道出售的票数，写代码实现。